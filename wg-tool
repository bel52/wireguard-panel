#!/usr/bin/env bash
set -euo pipefail

#
# wg-tool — PiVPN-like WireGuard client management
#
# Usage:
#   sudo wg-tool add <name> [endpoint]   Create client + add peer (no disconnect)
#   sudo wg-tool qr <name>               Print QR code for client config
#   sudo wg-tool list                    List all client configs and peers
#   sudo wg-tool revoke <name>           Remove peer + delete client files
#   sudo wg-tool show                    Show live WireGuard status
#
# Environment variables:
#   WG_INTERFACE - Specify which WireGuard interface to use (auto-detected if not set)
#

WG_DIR="/etc/wireguard"

# --------------- Auto-Detection ---------------

detect_interface() {
    # Check for WG_INTERFACE environment variable first
    if [[ -n "${WG_INTERFACE:-}" ]]; then
        echo "$WG_INTERFACE"
        return 0
    fi

    # Try to get interfaces from wg show
    local interfaces
    if interfaces=$(wg show interfaces 2>/dev/null) && [[ -n "$interfaces" ]]; then
        local iface_array=($interfaces)
        if [[ ${#iface_array[@]} -eq 1 ]]; then
            echo "${iface_array[0]}"
            return 0
        elif [[ ${#iface_array[@]} -eq 0 ]]; then
            return 1
        else
            # Multiple interfaces - auto-select: prefer wg0 if available, otherwise first alphabetically
            local selected
            for iface in "${iface_array[@]}"; do
                if [[ "$iface" == "wg0" ]]; then
                    selected="wg0"
                    break
                fi
            done
            if [[ -z "$selected" ]]; then
                # Sort and pick first
                selected=$(printf '%s\n' "${iface_array[@]}" | sort | head -1)
            fi
            # Only warn in interactive mode (not when called from web panel)
            if [[ -t 1 ]]; then
                echo "NOTE: Multiple interfaces found ($interfaces), auto-selected: $selected" >&2
                echo "Set WG_INTERFACE to change. Example: WG_INTERFACE=wg1 wg-tool list" >&2
            fi
            echo "$selected"
            return 0
        fi
    fi

    # Fallback: scan /etc/wireguard/*.conf
    local conf_files=("$WG_DIR"/*.conf)
    local valid_confs=()
    for conf in "${conf_files[@]}"; do
        [[ -f "$conf" ]] || continue
        local name
        name=$(basename "$conf" .conf)
        # Skip client directories
        [[ "$name" != *_clients* ]] && valid_confs+=("$name")
    done

    if [[ ${#valid_confs[@]} -eq 1 ]]; then
        echo "${valid_confs[0]}"
        return 0
    elif [[ ${#valid_confs[@]} -eq 0 ]]; then
        return 1
    else
        # Multiple configs - auto-select: prefer wg0 if available, otherwise first alphabetically
        local selected=""
        for conf_name in "${valid_confs[@]}"; do
            if [[ "$conf_name" == "wg0" ]]; then
                selected="wg0"
                break
            fi
        done
        if [[ -z "$selected" ]]; then
            selected=$(printf '%s\n' "${valid_confs[@]}" | sort | head -1)
        fi
        # Only warn in interactive mode (not when called from web panel)
        if [[ -t 1 ]]; then
            echo "NOTE: Multiple configs found (${valid_confs[*]}), auto-selected: $selected" >&2
            echo "Set WG_INTERFACE to change. Example: WG_INTERFACE=wg1 wg-tool list" >&2
        fi
        echo "$selected"
        return 0
    fi
}

detect_subnet_prefix() {
    local conf_file="$1"
    # Parse Address = x.x.x.x/xx and extract first 3 octets
    grep -E "^Address\s*=" "$conf_file" 2>/dev/null | head -1 | \
        sed -E 's/.*=\s*([0-9]+\.[0-9]+\.[0-9]+)\..*/\1/'
}

detect_server_pubkey() {
    local iface="$1"
    local pubkey

    # Try wg show first
    if pubkey=$(wg show "$iface" public-key 2>/dev/null) && [[ -n "$pubkey" ]]; then
        echo "$pubkey"
        return 0
    fi

    # Fallback: read server.pub file
    if [[ -f "${WG_DIR}/server.pub" ]]; then
        cat "${WG_DIR}/server.pub"
        return 0
    fi

    return 1
}

detect_server_port() {
    local conf_file="$1"
    # Parse ListenPort from config, default to 51820
    local port
    port=$(grep -E "^ListenPort\s*=" "$conf_file" 2>/dev/null | head -1 | \
        sed -E 's/.*=\s*([0-9]+).*/\1/')
    echo "${port:-51820}"
}

detect_dns() {
    local conf_file="$1"
    local prefix="$2"
    # First try to get DNS from the server's interface config
    local dns_line
    dns_line=$(grep -E "^DNS\s*=" "$conf_file" 2>/dev/null | head -1)
    if [[ -n "$dns_line" ]]; then
        local dns
        dns=$(echo "$dns_line" | sed -E 's/^DNS\s*=\s*//' | tr -d ' ')
        if [[ -n "$dns" ]]; then
            echo "$dns"
            return 0
        fi
    fi
    # Otherwise default to server IP (first in subnet)
    echo "${prefix}.1"
}

# Auto-detect interface
WG_IFACE=$(detect_interface) || {
    echo "ERROR: No WireGuard interfaces found!" >&2
    echo "Please ensure WireGuard is installed and configured." >&2
    echo "Expected: /etc/wireguard/<interface>.conf" >&2
    exit 1
}

# Set paths based on detected interface
WG_CONF="${WG_DIR}/${WG_IFACE}.conf"
CLIENT_DIR="${WG_DIR}/${WG_IFACE}_clients"

# Verify config exists
[[ -f "$WG_CONF" ]] || {
    echo "ERROR: WireGuard config not found: $WG_CONF" >&2
    exit 1
}

# Auto-detect other settings
VPN_PREFIX=$(detect_subnet_prefix "$WG_CONF") || {
    echo "ERROR: Could not parse subnet from $WG_CONF" >&2
    echo "Expected 'Address = x.x.x.x/xx' in [Interface] section" >&2
    exit 1
}
SERVER_PORT=$(detect_server_port "$WG_CONF")
DNS_IP=$(detect_dns "$WG_CONF" "$VPN_PREFIX")

# Get server public key (needed for client configs)
SERVER_PUB_KEY=""
if ! SERVER_PUB_KEY=$(detect_server_pubkey "$WG_IFACE"); then
    echo "WARNING: Could not determine server public key" >&2
    echo "Client configs may not work correctly" >&2
fi

# Legacy compatibility - keep SERVER_PUB path but prefer runtime detection
SERVER_PUB="${WG_DIR}/server.pub"

# --------------- End Auto-Detection ---------------

need_root() { [[ $EUID -eq 0 ]] || { echo "Run as root: sudo $0 $*"; exit 1; }; }

pub_ip() {
  curl -sS --max-time 3 https://api.ipify.org 2>/dev/null || true
}

next_ip() {
  mkdir -p "$CLIENT_DIR"
  local used
  used="$(grep -Eo "${VPN_PREFIX}\.[0-9]{1,3}" "$WG_CONF" 2>/dev/null | sort -Vu || true)"
  for i in $(seq 2 254); do
    local ip="${VPN_PREFIX}.${i}"
    if ! echo "$used" | grep -qx "$ip"; then
      echo "$ip"
      return 0
    fi
  done
  return 1
}

ensure_prereqs() {
  mkdir -p "$CLIENT_DIR"
  chmod 700 "$CLIENT_DIR"
  command -v wg >/dev/null
  command -v qrencode >/dev/null || apt-get -y install qrencode >/dev/null
  [[ -f "$WG_CONF" ]] || { echo "Missing: $WG_CONF"; exit 1; }
  # Server public key is auto-detected; only check for fallback file if runtime detection failed
  if [[ -z "$SERVER_PUB_KEY" ]] && [[ ! -f "$SERVER_PUB" ]]; then
    echo "Missing server public key: could not detect via 'wg show' and $SERVER_PUB not found"
    exit 1
  fi
}

# Apply config changes without restarting (no client disconnection)
# Falls back to restart if interface is down
apply_config() {
  if ip link show "$WG_IFACE" &>/dev/null; then
    # Interface is up — hot reload
    wg syncconf "$WG_IFACE" <(wg-quick strip "$WG_CONF")
    echo "(applied live via syncconf)"
  else
    # Interface is down — bring it up
    systemctl start "wg-quick@${WG_IFACE}"
    echo "(interface was down; started wg-quick@${WG_IFACE})"
  fi
}

# Check if NAT rule exists for this subnet, create if missing
check_nat_rule() {
  local subnet="${VPN_PREFIX}.0/24"

  # Try to detect the default outbound interface
  local out_iface
  out_iface=$(ip route show default 2>/dev/null | awk '{print $5}' | head -1)
  [[ -z "$out_iface" ]] && out_iface="eth0"  # Fallback

  # Check if NAT rule exists (check both generic and interface-specific)
  if iptables -t nat -C POSTROUTING -s "$subnet" -j MASQUERADE 2>/dev/null; then
    return 0  # Rule exists (generic)
  fi
  if iptables -t nat -C POSTROUTING -s "$subnet" -o "$out_iface" -j MASQUERADE 2>/dev/null; then
    return 0  # Rule exists (interface-specific)
  fi

  # NAT rule missing - create it
  echo "Creating NAT rule for $subnet via $out_iface..." >&2
  if iptables -t nat -A POSTROUTING -s "$subnet" -o "$out_iface" -j MASQUERADE; then
    echo "NAT rule created successfully" >&2
    # Try to persist (may fail if iptables-persistent not installed)
    if command -v netfilter-persistent >/dev/null 2>&1; then
      netfilter-persistent save 2>/dev/null || true
    elif command -v iptables-save >/dev/null 2>&1; then
      # Try to save to common locations
      iptables-save > /etc/iptables/rules.v4 2>/dev/null || \
      iptables-save > /etc/iptables.rules 2>/dev/null || true
    fi
  else
    echo "WARNING: Failed to create NAT rule. Clients may not have internet access." >&2
  fi
}

cmd_add() {
  need_root add "$@"
  ensure_prereqs

  # Ensure NAT rule exists for this subnet
  check_nat_rule

  local name=""
  local endpoint_host=""
  local dns_override=""

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dns)
        dns_override="${2:-}"
        shift 2
        ;;
      *)
        if [[ -z "$name" ]]; then
          name="$1"
        elif [[ -z "$endpoint_host" ]]; then
          endpoint_host="$1"
        fi
        shift
        ;;
    esac
  done

  [[ -n "$name" ]] || { echo "Usage: wg-tool add <client_name> [endpoint_host_or_ip] [--dns <dns_servers>]"; exit 1; }

  if [[ -z "$endpoint_host" ]]; then
    endpoint_host="$(pub_ip)"
    [[ -n "$endpoint_host" ]] || endpoint_host="YOUR_PUBLIC_IP_OR_DNS"
  fi

  # Determine DNS to use
  local client_dns
  if [[ -n "$dns_override" ]]; then
    client_dns="$dns_override"
  else
    client_dns="$DNS_IP"
  fi

  local ip
  ip="$(next_ip)" || { echo "No available IPs in ${VPN_PREFIX}.0/24"; exit 1; }

  local key="${CLIENT_DIR}/${name}.key"
  local pub="${CLIENT_DIR}/${name}.pub"
  local conf="${CLIENT_DIR}/${name}.conf"

  [[ ! -f "$conf" ]] || { echo "Client already exists: $conf"; exit 1; }

  umask 077
  wg genkey | tee "$key" | wg pubkey | tee "$pub" >/dev/null

  local client_priv client_pub server_pub
  client_priv="$(cat "$key")"
  client_pub="$(cat "$pub")"
  # Use auto-detected server public key, or fall back to file
  if [[ -n "$SERVER_PUB_KEY" ]]; then
    server_pub="$SERVER_PUB_KEY"
  else
    server_pub="$(cat "$SERVER_PUB")"
  fi

  # Append peer (with trailing newline for clean formatting)
  cat >> "$WG_CONF" <<EOP

[Peer]
# ${name}
PublicKey = ${client_pub}
AllowedIPs = ${ip}/32
EOP

  # Full tunnel (PiVPN-like)
  cat > "$conf" <<EOC
[Interface]
PrivateKey = ${client_priv}
Address = ${ip}/32
DNS = ${client_dns}

[Peer]
PublicKey = ${server_pub}
Endpoint = ${endpoint_host}:${SERVER_PORT}
AllowedIPs = 0.0.0.0/0, ::/0
PersistentKeepalive = 25
EOC

  chmod 600 "$conf"
  apply_config

  echo "OK: created ${conf}"
  echo "DNS: ${client_dns}"
  echo "Tip: wg-tool qr ${name}"
}

cmd_qr() {
  need_root qr "$@"
  ensure_prereqs
  local name="${1:-}"
  [[ -n "$name" ]] || { echo "Usage: wg-tool qr <client_name>"; exit 1; }
  local conf="${CLIENT_DIR}/${name}.conf"
  [[ -f "$conf" ]] || { echo "Missing: $conf"; exit 1; }
  qrencode -t ansiutf8 < "$conf"
}

cmd_show() {
  need_root show "$@"
  ensure_prereqs
  echo "== wg show ${WG_IFACE} =="
  wg show "$WG_IFACE"
  echo
  echo "== listening sockets (${SERVER_PORT}) =="
  ss -lunp | grep -E ":(${SERVER_PORT})\\b" || true
}

cmd_list() {
  need_root list "$@"
  ensure_prereqs
  echo "== Clients (configs in ${CLIENT_DIR}) =="
  ls -1 "$CLIENT_DIR"/*.conf 2>/dev/null | sed "s|^| - |" || echo " (none yet)"
  echo
  echo "== Peers in ${WG_IFACE}.conf =="
  awk '
    /^\[Peer\]/ {
      # Print previous peer if we had one
      if (inpeer) {
        printf(" - %s | %s | %s\n", (name ? name : "(no-name)"), pub, ip)
      }
      inpeer = 1
      name = ""
      pub = ""
      ip = ""
      next
    }
    inpeer && /^# / {
      name = $0
      sub(/^# /, "", name)
    }
    inpeer && /^PublicKey *=/ {
      pub = $0
      sub(/^PublicKey *= */, "", pub)
    }
    inpeer && /^AllowedIPs *=/ {
      ip = $0
      sub(/^AllowedIPs *= */, "", ip)
    }
    END {
      # Print final peer (fixes EOF-without-newline bug)
      if (inpeer) {
        printf(" - %s | %s | %s\n", (name ? name : "(no-name)"), pub, ip)
      }
    }
  ' "$WG_CONF" || true
}

cmd_revoke() {
  need_root revoke "$@"
  ensure_prereqs
  local name="${1:-}"
  [[ -n "$name" ]] || { echo "Usage: wg-tool revoke <client_name>"; exit 1; }

  local conf="${CLIENT_DIR}/${name}.conf"
  local pub="${CLIENT_DIR}/${name}.pub"

  [[ -f "$pub" ]] || { echo "Missing pubkey file: $pub"; exit 1; }
  local pk
  pk="$(cat "$pub")"

  # Remove peer block from config matching this PublicKey
  cp -a "$WG_CONF" "${WG_CONF}.bak_revoke_$(date +%Y%m%d_%H%M%S)"
  awk -v pk="$pk" '
    BEGIN {
      skip = 0
      blk = ""
      # Escape regex special characters in the public key
      # Base64 keys can contain + and / which are regex metacharacters
      gsub(/[[\\.^$*+?(){}|]/, "\\\\&", pk)
    }
    /^\[Peer\]/ {
      # Starting new peer block — flush previous if not skipping
      if (blk != "" && !skip) {
        printf "%s", blk
      }
      blk = $0 RS
      skip = 0
      next
    }
    /^\[Interface\]/ || /^\[/ {
      # Another section (safety) — flush peer block first
      if (blk != "" && !skip) {
        printf "%s", blk
      }
      blk = ""
      skip = 0
      print
      next
    }
    {
      if (blk != "") {
        blk = blk $0 RS
        if ($0 ~ "^PublicKey *= *" pk "$") {
          skip = 1
        }
      } else {
        print
      }
    }
    END {
      if (blk != "" && !skip) {
        printf "%s", blk
      }
    }
  ' "$WG_CONF" > "${WG_CONF}.tmp"
  mv "${WG_CONF}.tmp" "$WG_CONF"

  # Remove client files
  rm -f "${CLIENT_DIR}/${name}.conf" "${CLIENT_DIR}/${name}.key" "${CLIENT_DIR}/${name}.pub" 2>/dev/null || true

  apply_config
  echo "OK: revoked ${name}"
}

cmd_revoke_orphan() {
  # Revoke an orphaned peer by public key (for peers without config files)
  need_root revoke-orphan "$@"
  ensure_prereqs
  local pubkey="${1:-}"
  [[ -n "$pubkey" ]] || { echo "Usage: wg-tool revoke-orphan <public_key>"; exit 1; }

  # Validate pubkey format (base64, 44 chars with = padding)
  if [[ ! "$pubkey" =~ ^[A-Za-z0-9+/]{43}=$ ]]; then
    echo "Invalid public key format"
    exit 1
  fi

  # Check if peer exists in config
  if ! grep -q "PublicKey *= *${pubkey}" "$WG_CONF" 2>/dev/null; then
    echo "Peer not found in ${WG_CONF}"
    exit 1
  fi

  # Remove peer block from config matching this PublicKey
  cp -a "$WG_CONF" "${WG_CONF}.bak_revoke_$(date +%Y%m%d_%H%M%S)"
  awk -v pk="$pubkey" '
    BEGIN {
      skip = 0
      blk = ""
      # Escape regex special characters in the public key
      gsub(/[[\\.^$*+?(){}|]/, "\\\\&", pk)
    }
    /^\[Peer\]/ {
      if (blk != "" && !skip) {
        printf "%s", blk
      }
      blk = $0 RS
      skip = 0
      next
    }
    /^\[Interface\]/ || /^\[/ {
      if (blk != "" && !skip) {
        printf "%s", blk
      }
      blk = ""
      skip = 0
      print
      next
    }
    {
      if (blk != "") {
        blk = blk $0 RS
        if ($0 ~ "^PublicKey *= *" pk "$") {
          skip = 1
        }
      } else {
        print
      }
    }
    END {
      if (blk != "" && !skip) {
        printf "%s", blk
      }
    }
  ' "$WG_CONF" > "${WG_CONF}.tmp"
  mv "${WG_CONF}.tmp" "$WG_CONF"

  apply_config
  echo "OK: revoked orphan peer"
}

cmd_regen() {
  # Regenerate client config with new DNS settings
  need_root regen "$@"
  ensure_prereqs

  local name=""
  local dns_override=""

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dns)
        dns_override="${2:-}"
        shift 2
        ;;
      *)
        if [[ -z "$name" ]]; then
          name="$1"
        elif [[ -z "$dns_override" ]]; then
          # Allow dns as positional arg for backward compat
          dns_override="$1"
        fi
        shift
        ;;
    esac
  done

  [[ -n "$name" ]] || { echo "Usage: wg-tool regen <client_name> [--dns <dns_servers>]"; exit 1; }

  local conf="${CLIENT_DIR}/${name}.conf"
  [[ -f "$conf" ]] || { echo "ERROR: Client config not found: $conf"; exit 1; }

  # Read existing values from the config
  local private_key address
  private_key=$(grep -E "^PrivateKey\s*=" "$conf" | sed -E 's/^PrivateKey\s*=\s*//')
  address=$(grep -E "^Address\s*=" "$conf" | sed -E 's/^Address\s*=\s*//')

  [[ -n "$private_key" ]] || { echo "ERROR: Could not read PrivateKey from $conf"; exit 1; }
  [[ -n "$address" ]] || { echo "ERROR: Could not read Address from $conf"; exit 1; }

  # Get server info
  local server_pub
  if [[ -n "$SERVER_PUB_KEY" ]]; then
    server_pub="$SERVER_PUB_KEY"
  else
    server_pub="$(cat "$SERVER_PUB" 2>/dev/null)" || server_pub=""
  fi
  [[ -n "$server_pub" ]] || { echo "ERROR: Could not determine server public key"; exit 1; }

  # Get endpoint (use existing or detect)
  local endpoint
  endpoint=$(grep -E "^Endpoint\s*=" "$conf" 2>/dev/null | sed -E 's/^Endpoint\s*=\s*//')
  if [[ -z "$endpoint" ]]; then
    local pub_ip_addr
    pub_ip_addr="$(pub_ip)"
    [[ -n "$pub_ip_addr" ]] && endpoint="${pub_ip_addr}:${SERVER_PORT}" || endpoint="YOUR_PUBLIC_IP:${SERVER_PORT}"
  fi

  # Determine DNS to use
  local client_dns
  if [[ -n "$dns_override" ]]; then
    client_dns="$dns_override"
  else
    client_dns="$DNS_IP"
  fi

  # Create backup
  cp -a "$conf" "${conf}.bak_$(date +%Y%m%d_%H%M%S)"

  # Regenerate config
  cat > "$conf" <<EOC
[Interface]
PrivateKey = ${private_key}
Address = ${address}
DNS = ${client_dns}

[Peer]
PublicKey = ${server_pub}
Endpoint = ${endpoint}
AllowedIPs = 0.0.0.0/0, ::/0
PersistentKeepalive = 25
EOC

  chmod 600 "$conf"

  echo "OK: Regenerated config for ${name}"
  echo "DNS: ${client_dns}"
  echo "NOTE: Client must re-scan QR code or re-import config for changes to take effect."
}

cmd_get_dns() {
  # Get the current DNS setting for a client
  local name="${1:-}"
  [[ -n "$name" ]] || { echo "Usage: wg-tool get-dns <client_name>"; exit 1; }

  local conf="${CLIENT_DIR}/${name}.conf"
  [[ -f "$conf" ]] || { echo "ERROR: Client config not found: $conf"; exit 1; }

  local dns
  dns=$(grep -E "^DNS\s*=" "$conf" 2>/dev/null | sed -E 's/^DNS\s*=\s*//')
  if [[ -n "$dns" ]]; then
    echo "$dns"
  else
    echo "No DNS configured"
    exit 1
  fi
}

usage() {
  cat <<USAGE
Usage: sudo wg-tool <command> [args]

Commands:
  add <name> [endpoint] [--dns <servers>]  Create client + add peer
  regen <name> [--dns <servers>]           Regenerate config with new DNS
  get-dns <name>                           Show client's current DNS
  qr <name>                                Print QR code for client config
  list                                     List clients + peers
  revoke <name>                            Remove peer + delete client files
  revoke-orphan <pubkey>                   Remove orphan peer by public key
  show                                     Show wireguard status

Current configuration (auto-detected):
  Interface:   ${WG_IFACE}
  Config:      ${WG_CONF}
  Clients dir: ${CLIENT_DIR}
  Subnet:      ${VPN_PREFIX}.0/24
  DNS:         ${DNS_IP}

Environment variables:
  WG_INTERFACE  Override auto-detected interface (e.g., WG_INTERFACE=wg1)

DNS Presets (use with --dns):
  Pi-hole (server):    ${VPN_PREFIX}.1
  Google:              8.8.8.8, 8.8.4.4
  Cloudflare:          1.1.1.1, 1.0.0.1
  Cloudflare Family:   1.1.1.3, 1.0.0.3
  Quad9:               9.9.9.9, 149.112.112.112

Examples:
  wg-tool add phone                           # Uses default DNS
  wg-tool add laptop --dns "8.8.8.8, 8.8.4.4" # Uses Google DNS
  wg-tool regen phone --dns "1.1.1.1"         # Change phone's DNS to Cloudflare

Notes:
- Default endpoint is detected public IP; override with a DNS name if you have one.
- DNS for clients defaults to server IP (${DNS_IP}) unless overridden.
- Changes are applied live via 'wg syncconf' — existing clients stay connected.
- After 'regen', clients must re-import their config for DNS changes to apply.
USAGE
}

main() {
  local cmd="${1:-}"
  shift || true
  case "$cmd" in
    add) cmd_add "$@";;
    regen) cmd_regen "$@";;
    get-dns) cmd_get_dns "$@";;
    qr) cmd_qr "$@";;
    list) cmd_list;;
    revoke) cmd_revoke "$@";;
    revoke-orphan) cmd_revoke_orphan "$@";;
    show) cmd_show;;
    ""|-h|--help|help) usage;;
    *) echo "Unknown command: $cmd"; usage; exit 1;;
  esac
}

main "$@"
